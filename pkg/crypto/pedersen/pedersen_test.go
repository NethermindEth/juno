package pedersen

import (
	"crypto/rand"
	"fmt"
	"math/big"
	"testing"
)

var benchmarkArrayDigestData []*big.Int

func init() {
	initBenchmarkArrayDigest()
}

// BenchmarkDigest runs a benchmark on the Digest function by hashing a
// *big.Int with a value of 0 N times.
func BenchmarkDigest(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Digest(new(big.Int))
	}
}

// ExampleDigest showcases the use of the Pedersen hash function in the
// autogenerated documentation.
func ExampleDigest() {
	a, _ := new(big.Int).SetString("3d937c035c878245caf64531a5756109c53068da139362728feb561405371cb", 16)
	b, _ := new(big.Int).SetString("208a0a10250e382e1e4bbe2880906c2791bf6275695e02fbbc6aeff9cd8b31a", 16)
	dgst, err := Digest(a, b)
	if err != nil {
		panic(err)
	}
	fmt.Printf("0x%x\n", dgst)
	// Output:
	// 0x30e480bed5fe53fa909cc0f8c4d99b8f9f2c016be4c41e13a4848797979c662
}

// TestDigest does a basic test of the Pedersen hash function where the
// test cases chosen are the canonical ones that appear in the Python
// implementation of the same function by Starkware.
func TestDigest(t *testing.T) {
	// See https://github.com/starkware-libs/starkex-resources/blob/44a15c7d1bdafda15766ea0fc2e0866e970e39c1/crypto/starkware/crypto/signature/signature_test_data.json#L85-L96.
	var tests = [...]struct {
		input1, input2, want string
	}{
		{
			"3d937c035c878245caf64531a5756109c53068da139362728feb561405371cb",
			"208a0a10250e382e1e4bbe2880906c2791bf6275695e02fbbc6aeff9cd8b31a",
			"30e480bed5fe53fa909cc0f8c4d99b8f9f2c016be4c41e13a4848797979c662",
		},
		{
			"58f580910a6ca59b28927c08fe6c43e2e303ca384badc365795fc645d479d45",
			"78734f65a067be9bdb39de18434d71e79f7b6466a4b66bbd979ab9e7515fe0b",
			"68cc0b76cddd1dd4ed2301ada9b7c872b23875d5ff837b3a87993e0d9996b87",
		},
	}
	for _, test := range tests {
		a, _ := new(big.Int).SetString(test.input1, 16)
		b, _ := new(big.Int).SetString(test.input2, 16)
		want, _ := new(big.Int).SetString(test.want, 16)
		got, _ := Digest(a, b)
		if got.Cmp(want) != 0 {
			t.Errorf("Digest(0x%x, 0x%x) = 0x%x, want 0x%x", a, b, got, want)
		}
	}
}

func initBenchmarkArrayDigest() {
	// max = 2**252 - 1
	max := new(big.Int)
	max.Exp(big.NewInt(2), big.NewInt(252), nil).Sub(max, big.NewInt(1))
	// Building a batch of 20 random big.Int between 0 and 2**252-1.
	for i := 0; i < 20; i++ {
		// XXX: Use big.Int.Rand instead. We don't need secure randomness
		// here. In fact, this is will skew benchmark results because of the
		// associated overhead.
		value, err := rand.Int(rand.Reader, max)
		if err != nil {
			panic(err)
		}
		benchmarkArrayDigestData = append(benchmarkArrayDigestData, value)
	}
}

func BenchmarkArrayDigest(b *testing.B) {
	for i := 0; i < b.N; i++ {
		ArrayDigest(benchmarkArrayDigestData...)
	}
}

// XXX: Use hexadecimal encoding to keep it consistent with the rest of 
// the package.
func TestArrayDigest(t *testing.T) {
	var tests = [...]struct {
		input []string
		want  string
	}{
		{
			input: []string{"1", "2", "3", "4", "5"},
			want:  "3442134774288875752012730520904650962184640568595562887119811371865001706826",
		},
		{
			input: []string{
				"1713931329540660377023406109199410414810705867260802078187082345529207694986",
				"152666792071518830868575557812948353041420400780739481342941381225525861407",
				"1668503676786377725805489344771023921079126552019160156920634619255970485781",
				"3198314560325546891798262260233968848553481119985289977998522774043088964633",
				"469920083884440505232139273974987899994000885911056071194573294589259802432",
			},
			want: "1675665479632492174039983244955429515271444758833709467939659125819654522174",
		},
	}
	for _, test := range tests {
		data := []*big.Int{}
		for _, item := range test.input {
			v, _ := new(big.Int).SetString(item, 10)
			data = append(data, v)
		}
		want, _ := new(big.Int).SetString(test.want, 10)
		got, _ := ArrayDigest(data...)
		if got.Cmp(want) != 0 {
			t.Errorf("DigestArray(%v) = %v, want %v", data, got, want)
		}
	}
}
