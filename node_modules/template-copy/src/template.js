'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var fs = require('fs');
var path = require('path');
var _glob = require('glob');
var _mkdirp = require('mkdirp');
var assign = require('deep-assign');
var through2 = require('through2');
var _template = require('lodash.template');
var minimist = require('minimist');
var exists = fs.existsSync;

var debug = require('debug')('template-copy');
var log = require('./log');

var node = function node(resolve, reject) {
  return function (err) {
    err ? reject(err) : resolve();
  };
};

var Template = function () {
  _createClass(Template, [{
    key: 'messages',
    get: function get() {
      return {
        NOT_A_DIRECTORY: 'target \'%s\' is not a directory',
        MISSING_FILE_OPERAND: 'missing file operand',
        MISSING_DESTINATION_FILE_OPERAND: 'missing destination file operand after \'%s\''
      };
    }
  }, {
    key: 'templateSettings',
    get: function get() {
      return {
        interpolate: /{{(.+?)}}/g
      };
    }
  }, {
    key: 'inquirer',
    get: function get() {
      try {
        return require('inquirer').createPromptModule();
      } catch (e) {
        this.error('Inquirer is not available, skipping prompt');
      }
    }
  }, {
    key: 'globSettings',
    get: function get() {
      return {
        dot: true,
        nodir: true,
        matchBase: true
      };
    }
  }, {
    key: 'arrow',
    get: function get() {
      return '=>';
    }
  }]);

  function Template() {
    var _this = this;

    var argv = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    _classCallCheck(this, Template);

    this.options = options;
    this.options.argv = this.options.argv || {};

    this.argv = this.parse(argv);
    this.env = options.env || Object.assign({}, process.env);

    this.env = Object.keys(this.env).filter(function (name) {
      return (/^hcp_/i.test(name)
      );
    }).map(function (name) {
      return { name: name, value: _this.env[name] };
    }).reduce(function (a, b) {
      a[b.name.replace(/^hcp_/i, '')] = b.value;
      return a;
    }, {});
  }

  _createClass(Template, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      var files = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

      this.files = files;
      this.dest = files.pop();
      this.dir = this.dest && this.dest.slice(-1)[0] === '/';

      this.check();

      this.files = files.map(this.globSync).reduce(this.flatten, []);
      if (!this.files.length) this.files = files;

      var promises = this.files.map(function (file) {
        return _this2.write(file, _this2.dest);
      });
      return Promise.all(promises).catch(function (err) {
        return _this2.error(err);
      });
    }
  }, {
    key: 'parse',
    value: function parse(args) {
      var alias = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      return minimist(args, alias);
    }
  }, {
    key: 'write',
    value: function write(file, dest) {
      var promise = this.dir ? this.mkdirp(this.dest) : this.noop();
      return promise.then(this.copy.bind(this, file));
    }
  }, {
    key: 'copy',
    value: function copy(file) {
      var _this3 = this;

      var dest = this.dir ? path.join(this.dest, path.basename(file)) : this.dest;
      dest = path.resolve(dest);
      return this.exists(dest).then(function (filepath) {
        var ext = path.extname(file);
        if (filepath && ext === '.json') return _this3.json(file, dest);
        return _this3.file(file, dest);
      });
    }
  }, {
    key: 'file',
    value: function file(_file, dest) {
      var _this4 = this;

      return this.isDirectory(_file).then(function (dir) {
        if (dir) return _this4.dirCopy(_file, dest);

        return _this4.exists(dest).then(function (filepath) {
          if (filepath) {
            _this4.warn('%s already exists, skipping ...', filepath);
            return _this4.noop();
          }

          return _this4.mkdirp(path.dirname(dest)).then(function () {
            return _this4.fileCopy(_file, dest);
          });
        });
      });
    }
  }, {
    key: 'dirCopy',
    value: function dirCopy(from, to) {
      var _this5 = this;

      debug('dir copy', from, to);
      return this.glob(path.join(from, '**')).then(function (files) {
        _this5.files = _this5.files.concat(files);

        files = files.concat().map(function (file) {
          var rel = file.replace(from, '');
          return { rel: rel, file: file };
        });

        _this5.info('Directory copy %s to %s', from, _this5.dest);
        return _this5.recurse(files);
      });
    }
  }, {
    key: 'recurse',
    value: function recurse() {
      var files = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

      var file = files.shift();
      if (!file) return true;

      return this.file(file.file, path.join(this.dest, file.rel)).then(this.recurse.bind(this, files));
    }
  }, {
    key: 'fileCopy',
    value: function fileCopy(file, dest) {
      var _this6 = this;

      this.success('%s %s %s', file, this.arrow, dest);

      file = path.resolve(file);
      return new Promise(function (r, errback) {
        debug('cp', file, dest);
        var input = fs.createReadStream(file);
        var out = fs.createWriteStream(dest);
        var chunks = '';

        input.setEncoding('utf8');
        input.on('data', function (chunk) {
          chunks += chunk;
        });

        input.pipe(_this6.transform(file, dest)).pipe(out).on('error', errback).on('close', r);
      });
    }
  }, {
    key: 'transform',
    value: function transform() {
      var render = this.render.bind(this);
      return through2(function (chunk, enc, done) {
        var _this7 = this;

        render(chunk + '', function (err, res) {
          if (err) return done(err);
          _this7.push(res);
          return done();
        });
      });
    }
  }, {
    key: 'placeholders',
    value: function placeholders() {
      var _this8 = this;

      var content = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

      var placeholders = content.match(/{{([^}]+}})/g);
      if (!placeholders) return;

      placeholders = placeholders.map(function (p) {
        return p.replace(/{{\s*/, '').replace(/\s*}}/, '');
      });

      placeholders = placeholders.reduce(this.uniq.bind(this), []);

      // skip values already available in env or options
      placeholders = placeholders.filter(function (name) {
        return !(name in _this8.options || name in _this8.env);
      });

      return placeholders;
    }
  }, {
    key: 'question',
    value: function question(name, message) {
      return {
        type: 'input',
        message: name || message,
        default: this.argv[name] || this.env[name] || name,
        name: name
      };
    }
  }, {
    key: 'render',
    value: function render(content, done) {
      var _this9 = this;

      var placeholders = this.placeholders(content);
      if (!placeholders) return this.template(content, {}, done);

      var questions = placeholders.map(this.question, this);

      var defaults = placeholders.map(function (name) {
        return { name: name };
      });

      var argv = Object.assign({}, this.options);
      var data = Object.assign({}, this.env, argv, defaults);

      if (!questions.length) return this.template(content, data, done);

      this.prompt(questions).catch(done).then(function (answers) {
        placeholders.forEach(function (p) {
          var answer = answers[p] === 'true' ? true : answers[p] === 'false' ? false : answers[p];

          data[p] = typeof answer !== 'undefined' ? answer : _this9.argv[p] || p;
        });

        _this9.template(content, data, done);
      });
    }
  }, {
    key: 'prompt',
    value: function prompt(questions, done) {
      var inquirer = this.inquirer;
      return inquirer ? inquirer(questions, done) : done();
    }
  }, {
    key: 'template',
    value: function template(content, data, done) {
      var tpl = _template(content, this.templateSettings);
      var output = tpl(data);
      done(null, output);
    }
  }, {
    key: 'json',
    value: function json(file, destination) {
      var input = this.readJSON(path.resolve(file));
      var dest = path.resolve(destination);
      dest = exists(dest) ? this.readJSON(dest) : {};

      var output = assign({}, input, dest);

      return new Promise(function (r, errback) {
        fs.writeFile(destination, JSON.stringify(output, null, 2), node(r, errback));
      });
    }
  }, {
    key: 'readJSON',
    value: function readJSON(file) {
      try {
        return require(file);
      } catch (e) {
        this.warn(e.message);
        return {};
      }
    }
  }, {
    key: 'noop',
    value: function noop() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return new Promise(function (r, errback) {
        return r.apply(undefined, args);
      });
    }
  }, {
    key: 'mkdirp',
    value: function mkdirp(filepath) {
      return this.isDirectory(filepath).then(function (isDir) {
        if (isDir) return filepath;
        return new Promise(function (r, errback) {
          _mkdirp(path.resolve(filepath), node(r, errback));
        });
      });
    }
  }, {
    key: 'exists',
    value: function exists(filepath) {
      return new Promise(function (r, errback) {
        fs.exists(filepath, function (exists) {
          r(exists ? filepath : false);
        });
      });
    }
  }, {
    key: 'isDirectory',
    value: function isDirectory(filepath) {
      return new Promise(function (r, errback) {
        fs.stat(filepath, function (err, stat) {
          if (err && err.code === 'ENOENT') return r(false);
          err ? errback(err) : r(stat.isDirectory());
        });
      });
    }
  }, {
    key: 'globSync',
    value: function globSync(pattern) {
      var opts = arguments.length <= 1 || arguments[1] === undefined ? this.globSettings : arguments[1];

      return _glob.sync(pattern, opts);
    }
  }, {
    key: 'glob',
    value: function glob(pattern) {
      var opts = arguments.length <= 1 || arguments[1] === undefined ? this.globSettings : arguments[1];

      return new Promise(function (r, errback) {
        _glob(pattern, opts, function (err, files) {
          err ? errback(err) : r(files);
        });
      });
    }
  }, {
    key: 'flatten',
    value: function flatten(a, b) {
      return a.concat(b);
    }
  }, {
    key: 'uniq',
    value: function uniq(a, b) {
      if (a.indexOf(b) !== -1) return a;
      return a.concat(b);
    }
  }, {
    key: 'check',
    value: function check() {
      if (!this.files.length) {
        if (this.dest) this.error(this.messages.MISSING_DESTINATION_FILE_OPERAND, this.dest);else this.error(this.messages.MISSING_FILE_OPERAND);
        process.exit(1);
      }

      if (this.files.length > 1 && this.dest) {
        if (!this.dir) this.error(this.messages.NOT_A_DIRECTORY, this.dest).exit(1);
      }
    }
  }]);

  return Template;
}();

exports.default = Template;


Object.assign(Template.prototype, log);
module.exports = exports['default'];